.. _the_natural_numbers_and_induction:

The Natural Numbers and Induction
=================================

This chapter marks a transition from the abstract to the concrete. Viewing the mathematical universe in terms of sets, relations, and functions gives us useful ways of thinking about mathematical objects and structures and the relationships between them. At some point, however, we need to start thinking about *particular* mathematical objects and structures, and the natural numbers are a good place to start. The nineteenth century mathematician Leopold Kronecker once proclaimed "God created the whole numbers; everything else is the work of man." By this he meant that the natural numbers (and the integers, which we will also discuss below) are a fundamental component of the mathematical universe, and that many other objects and structures of interest can be constructed from these.

In this chapter, we will consider the natural numbers and the basic principles that govern them. In :numref:`Chapter %s <the_natural_numbers_and_induction_in_lean>` we will see that even basic operations like addition and multiplication can be defined using means described here, and their properties derived from these basic principles. Our presentation in this chapter will remain informal, however. In Chapter 19, we will see how these principles play out in number theory, one of the oldest and most venerable branches of mathematics.

The Principle of Induction
--------------------------

The set of natural numbers is the set

.. math::

   \mathbb{N} = \{ 0, 1, 2, 3, \ldots \}.

In the past, opinions have differed as to whether the set of natural numbers should start with 0 or 1, but these days most mathematicians take them to start with 0. Logicians often call the function :math:`s(n) = n + 1` the *successor* function, since it maps each natural number, :math:`n`, to the one that follows it. What makes the natural numbers special is that they are *generated* by the number zero and the successor function, which is to say, the only way to construct a natural number is to start with :math:`0` and apply the successor function finitely many times. From a foundational standpoint, we are in danger of running into a circularity here, because it is not clear how we can explain what it means to apply a function "finitely many times" without talking about the natural numbers themselves. But the following principle, known as the *principle of induction*, describes this essential property of the natural numbers in a non-circular way.

----

**Principle of Induction.** Let :math:`P` be any property of natural numbers. Suppose :math:`P` holds of zero, and whenever :math:`P` holds of a natural number :math:`n`, then it holds of its successor, :math:`n + 1`. Then :math:`P` holds of every natural number.

----

This reflects the image of the natural numbers as being generated by zero and the successor operation: by covering the zero and successor cases, we take care of all the natural numbers.

The principle of induction provides a recipe for proving that every natural number has a certain property: to show that :math:`P` holds of every natural number, show that it holds of :math:`0`, and show that whenever it holds of some number :math:`n`, it holds of :math:`n + 1`. This form of proof is called a *proof by induction*. The first required task is called the *base case*, and the second required task is called the *induction step*. The induction step requires temporarily fixing a natural number :math:`n`, assuming that :math:`P` holds of :math:`n`, and then showing that :math:`P` holds of :math:`n + 1`. In this context, the assumption that :math:`P` holds of :math:`n` is called the *inductive hypothesis*.

You can visualize proof by induction as a method of knocking down an infinite stream of dominoes, all at once. We set the mechanism in place and knock down domino 0 (the base case), and every domino knocks down the next domino (the induction step). So domino 0 knocks down domino 1; that knocks down domino 2, and so on.

Here is an example of a proof by induction.

----

**Theorem.** For every natural number :math:`n`,

.. math::

   1 + 2 + \ldots + 2^n = 2^{n+1} - 1.

**Proof.** We prove this by induction on :math:`n`. In the base case, when :math:`n = 0`, we have :math:`1 = 2^{0+1} - 1`, as required.

For the induction step, fix :math:`n`, and assume the *inductive hypothesis*

.. math::

   1 + 2 + \ldots + 2^n = 2^{n+1} - 1.

We need to show that this same claim holds with :math:`n` replaced by :math:`n + 1`. But this is just a calculation:

.. math::

   1 + 2 + \ldots + 2^{n+1} & = (1 + 2 + \ldots + 2^n) + 2^{n+1} \\
   & = 2^{n+1} - 1 + 2^{n+1} \\
   & = 2 \cdot 2^{n+1} - 1 \\
   & = 2^{n+2} - 1.

----

In the notation of first-order logic, if we write :math:`P(n)` to mean that :math:`P` holds of :math:`n`, we could express the principle of induction as follows:

.. math::

   P(0) \wedge \forall n \; (P(n) \to P(n + 1)) \to \forall n \; P(n).

But notice that the principle of induction says that the axiom holds *for every property* :math:`P`, which means that we should properly use a universal quantifier for that, too:

.. math::

   \forall P \; (P(0) \wedge \forall n \; (P(n) \to P(n + 1)) \to \forall n \; P(n)).

Quantifying over properties takes us out of the realm of first-order logic; induction is therefore a second-order principle.

The pattern for a proof by induction is expressed even more naturally by the following natural deduction rule:

.. raw:: html

   <img src="_static/the_natural_numbers_and_induction.1.png">

.. raw:: latex

    \begin{prooftree}
      \AXM{P(0)}
      \AXM{}
      \RLM{1}
      \UIM{P(n)}
      \noLine
      \UIM{\vdots}
      \noLine
      \UIM{P(n+1)}
      \BIM{\forall n \; P(n)}
    \end{prooftree}

You should think about how some of the proofs in this chapter could be represented formally using natural deduction.

For another example of a proof by induction, let us derive a formula that, given any finite set :math:`S`, determines the number of subsets of :math:`S`. For example, there are four subsets of the two-element set :math:`\{1, 2\}`, namely :math:`\emptyset`, :math:`\{1\}`, :math:`\{2\}`, and :math:`\{1, 2\}`. You should convince yourself that there are eight subsets of the set :math:`\{1, 2, 3\}`. The following theorem establishes the general pattern.

----

**Theorem.** For any finite set :math:`S`, if :math:`S` has :math:`n` elements, then there are :math:`2^n` subsets of :math:`S`.

**Proof.** We use induction on :math:`n`. In the base case, there is only one set with :math:`0` elements, the empty set, and there is exactly one subset of the empty set, as required.

In the inductive case, suppose :math:`S` has :math:`n + 1` elements. Let :math:`a` be any element of :math:`S`, and let :math:`S'` be the set containing the remaining :math:`n` elements. In order to count the subsets of :math:`S`, we divide them into two groups.

First, we consider the subsets of :math:`S` that don't contain :math:`a`. These are exactly the subsets of :math:`S'`, and by the inductive hypothesis, there are :math:`2^n` of those.

Next we consider the subsets of :math:`S` that *do* contain :math:`a`. Each of these is obtained by choosing a subset of :math:`S'` and adding :math:`a`. Since there are :math:`2^n` subsets of :math:`S'`, there are :math:`2^n` subsets of :math:`S` that contain :math:`a`.

Taken together, then, there are :math:`2^n + 2^n = 2^{n+1}` subsets of :math:`S`, as required.

----

We have seen that there is a correspondence between properties of a domain and subsets of a domain. For every property :math:`P` of natural numbers, we can consider the set :math:`S` of natural numbers with that property, and for every set of natural numbers, we can consider the property of being in that set. For example, we can talk about the property of being even, or talk about the set of even numbers. Under this correspondence, the principle of induction can be cast as follows:

----

**Principle of Induction.** Let :math:`S` be any set of natural numbers that contains :math:`0` and is closed under the successor operation. Then :math:`S = \mathbb{N}`.

----

Here, saying that :math:`S` is "closed under the successor operation" means that whenever a number :math:`n` is in :math:`S`, so is :math:`n + 1`.

Variants of Induction
---------------------

In this section, we will consider variations on the principle of induction that are often useful. It is important to recognize that each of these can be justified using the principle of induction as stated in the last section, so they need not be taken as fundamental.

The first one is no great shakes: instead of starting from :math:`0`, we can start from any natural number, :math:`m`.

----

**Principle of Induction from a Starting Point.** Let :math:`P` be any property of natural numbers, and let :math:`m` be any natural number. Suppose :math:`P` holds of :math:`m`, and whenever :math:`P` holds of a natural number :math:`n` greater than or equal to :math:`m`, then it holds of its successor, :math:`n + 1`. Then :math:`P` holds of every natural number greater than or equal to :math:`m`.

----

Assuming the hypotheses of this last principle, if we let :math:`P'(n)` be the property ":math:`P` holds of :math:`m + n`," we can prove that :math:`P'` holds of every :math:`n` by the ordinary principle of induction. But this means that :math:`P` holds of every number greater than or equal to :math:`m`.

Here is one example of a proof using this variant of induction.

----

**Theorem.** For every natural number :math:`n \geq 5`, :math:`2^n > n^2`.

**Proof.** By induction on :math:`n`. When :math:`n = 5`, we have :math:`2^n = 32 > 25 = n^2`, as required.

For the induction step, suppose :math:`n \ge 5` and :math:`2^n > n^2`. Since :math:`n` is greater than or equal to :math:`5`, we have :math:`2n + 1 \leq 3 n \leq n^2`, and so

.. math::

    (n+1)^2 &= n^2 + 2n + 1 \\
     & \leq n^2 + n^2 \\
     & < 2^n + 2^n \\
     & = 2^{n+1}.

----

For another example, let us derive a formula for the sum total of the angles in a convex polygon. A polygon is said to be *convex* if every line between two vertices stays inside the polygon. We will accept without proof the visually obvious fact that one can subdivide any convex polygon with more than three sides into a triangle and a convex polygon with one fewer side, namely, by closing off any two consecutive sides to form a triangle. We will also accept, without proof, the basic geometric fact that the sum of the angles of any triangle is 180 degrees.

----

**Theorem.** For any :math:`n \geq 3`, the sum of the angles of any convex :math:`n`-gon is :math:`180(n - 2)`.

**Proof.** In the base case, when :math:`n = 3`, this reduces to the statement that the sum of the angles in any triangle is 180 degrees.

For the induction step, suppose :math:`n \geq 3`, and let :math:`P` be a convex :math:`(n+1)`-gon. Divide :math:`P` into a triangle and an :math:`n`-gon. By the inductive hypotheses, the sum of the angles of the :math:`n`-gon is :math:`180(n-2)` degrees, and the sum of the angles of the triangle is :math:`180` degrees. The measures of these angles taken together make up the sum of the measures of the angles of :math:`P`, for a total of :math:`180(n-2) + 180 = 180(n-1)` degrees.

----

For our second example, we will consider the principle of *complete induction*, also sometimes known as *total induction*.

----

**Principle of Complete Induction.** Let :math:`P` be any property that satisfies the following: for any natural number :math:`n`, whenever :math:`P` holds of every number less than :math:`n`, it also holds of :math:`n`. Then :math:`P` holds of every natural number.

----

Notice that there is no need to break out a special case for zero: for any property :math:`P`, :math:`P` holds of all the natural numbers less than zero, for the trivial reason that there aren't any! So, in particular, any such property automatically holds of zero.

Notice also that if such a property :math:`P` holds of every number less than :math:`n`, then it also holds of every number less than :math:`n + 1` (why?). So, for such a :math:`P`, the ordinary principle of induction implies that for every natural number :math:`n`, :math:`P` holds of every natural number less than :math:`n`. But this is just a roundabout way of saying that :math:`P` holds of every natural number. In other words, we have justified the principle of complete induction using ordinary induction.

To use the principle of complete induction we merely have to let :math:`n` be any natural number and show that :math:`P` holds of :math:`n`, assuming that it holds of every smaller number. Compare this to the ordinary principle of induction, which requires us to show :math:`P (n + 1)` assuming only :math:`P(n)`. The following example of the use of this principle is taken verbatim from the introduction to this book:

----

**Theorem.** Every natural number greater than or equal to 2 can be written as a product of primes.

**Proof.** We proceed by induction on :math:`n`. Let :math:`n` be any natural number greater than 2. If :math:`n` is prime, we are done; we can consider :math:`n` itself as a product with one factor. Otherwise, :math:`n` is composite, and we can write :math:`n = m \cdot k` where :math:`m` and :math:`k` are smaller than :math:`n` and greater than 1. By the inductive hypothesis, each of :math:`m` and :math:`k` can be written as a product of primes:

.. math::

   m = p_1 \cdot p_2 \cdot \ldots \cdot p_u \\
   k = q_1 \cdot q_2 \cdot \ldots \cdot q_v.

But then we have

.. math::


   n = m \cdot k = p_1 \cdot p_2 \cdot \ldots \cdot p_u \cdot q_1 \cdot
   q_2 \cdot \ldots \cdot q_v.

We see that :math:`n` is a product of primes, as required.

----

Finally, we will consider another formulation of induction, known as the least element principle.

----

**The Least Element Principle.** Suppose :math:`P` is some property of natural numbers, and suppose :math:`P` holds of some :math:`n`. Then there is a smallest value of :math:`n` for which :math:`P` holds.

----

In fact, using classical reasoning, this is equivalent to the principle of complete induction. To see this, consider the contrapositive of the statement above: "if there is no smallest value for which :math:`P` holds, then :math:`P` doesn't hold of any natural number." Let :math:`Q(n)` be the property ":math:`P` does *not* hold of :math:`n`." Saying that there is no smallest value for which :math:`P` holds means that, for every :math:`n`, if :math:`P` holds at :math:`n`, then it holds of some number smaller than :math:`n`; and this is equivalent to saying that, for every :math:`n`, if :math:`Q` doesn't hold at :math:`n`, then there is a smaller value for which :math:`Q` doesn't hold. And *that* is equivalent to saying that if :math:`Q` holds for every number less than :math:`n`, it holds for :math:`n` as well. Similarly, saying that :math:`P` doesn't hold of any natural number is equivalent to saying that :math:`Q` holds of every natural number. In other words, replacing the least element principle by its contrapositive, and replacing :math:`P` by "not :math:`Q`," we have the principle of complete induction. Since every statement is equivalent to its contrapositive, and every predicate has its negated version, the two principles are the same.

It is not surprising, then, that the least element principle can be used in much the same way as the principle of complete induction. Here, for example, is a formulation of the previous proof in these terms. Notice that it is phrased as a proof by contradiction.

----

**Theorem.** Every natural number greater than equal to 2 can be written as a product of primes.

**Proof.** Suppose, to the contrary, some natural number greater than or equal to 2 cannot be written as a product of primes. By the least element principle, there is a smallest such element; call it :math:`n`. Then :math:`n` is not prime, and since it is greater than or equal to 2, it must be composite. Hence we can write :math:`n = m \cdot k` where :math:`m` and :math:`k` are smaller than :math:`n` and greater than 1. By the assumption on :math:`n`, each of :math:`m` and :math:`k` can be written as a product of primes:

.. math::

   m = p_1 \cdot p_2 \cdot \ldots \cdot p_u \\
   k = q_1 \cdot q_2 \cdot \ldots \cdot q_v.

But then we have

.. math::


   n = m \cdot k = p_1 \cdot p_2 \cdot \ldots \cdot p_u \cdot q_1 \cdot
   q_2 \cdot \ldots \cdot q_v.

We see that :math:`n` is a product of primes, contradicting the fact that :math:`n` cannot be
written as a product of primes.

----

Here is another example:

----

**Theorem.** Every natural number is interesting.

**Proof.** Suppose, to the contrary, some natural number is uninteresting. Then there is a smallest one, :math:`n`. In other words, :math:`n` is the smallest uninteresting number. But that is really interesting! Contradiction.

----

.. _recursive_definitions:

Recursive Definitions
---------------------

Suppose I tell you that I have a function :math:`f : \mathbb{N} \to \mathbb{N}` in
mind, satisfying the following properties:

.. math::

    f(0) & = 1 \\
    f(n + 1) & = 2 \cdot f(n)

What can you infer about :math:`f`? Try calculating a few values:

.. math::

     f(1) & = f(0 + 1) = 2 \cdot f(0) = 2 \\
     f(2) & = f(1 + 1) = 2 \cdot f(1) = 4 \\
     f(3) & = f(2 + 1) = 2 \cdot f(2) = 8

It soon becomes apparent that for every :math:`n`, :math:`f(n) = 2^n`.

What is more interesting is that the two conditions above specify *all* the values of :math:`f`, which is to say, there is exactly one function meeting the specification above. In fact, it does not matter that :math:`f` takes values in the natural numbers; it could take values in any other domain. All that is needed is a value of :math:`f(0)` and a way to compute the value of :math:`f(n+1)` in terms of :math:`n` and :math:`f(n)`. This is what the principle of definition by recursion asserts:

----

**Principle of Definition by Recursion**. Let :math:`A` be any set, and suppose :math:`a` is in :math:`A`, and :math:`g : \mathbb{N} \times A \to A`. Then there is a unique function :math:`f` satisfying the following two clauses:

.. math::

    f(0) & = a \\
    f(n + 1) & = g(n, f(n)).

----

The principle of recursive definition makes two claims at once: first, that there is a function :math:`f` satisfying the clauses above, and, second, that any two functions :math:`f_1` and :math:`f_2` satisfying those clauses are equal, which is to say, they have the same values for every input. In the example with which we began this section, :math:`A` is just :math:`\mathbb{N}` and :math:`g(n, f(n)) = 2 \cdot f(n)`.

In some axiomatic frameworks, the principle of recursive definition can be justified using the principle of induction. In others, the principle of induction can be viewed as a special case of the principle of recursive definition. For now, we will simply take both to be fundamental properties of the natural numbers.

As another example of a recursive definition, consider the function :math:`g : \mathbb{N} \to \mathbb{N}` defined recursively by the following clauses:

.. math::

     g(0) & = 1 \\
     g(n+1) & = (n + 1) \cdot g(n)

Try calculating the first few values. Unwrapping the definition, we see that :math:`g(n) = 1 \cdot 2 \cdot 3 \cdot \ldots \cdot (n-1) \cdot n` for every :math:`n`; indeed, definition by recursion is usually the proper way to make expressions using "…" precise. The value :math:`g(n)` is read ":math:`n` factorial," and written :math:`n!`.

Indeed, summation notation

.. math::

   \sum_{i < n} f (i) = f(0) + f(1) + \ldots + f(n-1)

and product notation

.. math::

   \prod_{i < n} f (i) = f(0) \cdot f(1) \cdot \cdots \cdot f(n-1)

can also be made precise using recursive definitions. For example, the function :math:`k(n) = \sum_{i < n} f (i)` can be defined recursively as follows:

.. math::

   k(0) &= 0 \\
   k(n+1) &= k(n) + f(n)

Induction and recursion are complementary principles, and typically the way to prove something about a recursively defined function is to use the principle of induction. For example, the following theorem provides a formulas for the sum :math:`1 + 2 + \ldots + n`, in terms of :math:`n`.

----

**Theorem.** For every :math:`n`, :math:`\sum_{i < n + 1} i = n (n + 1) / 2`.

**Proof.** In the base case, when :math:`n = 0`, both sides are equal to :math:`0`.

In the inductive step, we have

.. math::

   \sum_{i < n + 2} i & = \left(\sum_{i < n + 1} i\right) + (n + 1) \\
   & = n (n + 1) / 2 + n + 1 \\
   & = \frac{n^2 +n}{2} + \frac{2n + 2}{2} \\
   & = \frac{n^2 + 3n + 2}{2} \\
   & = \frac{(n+1)(n+2)}{2}.

----

There are just as many variations on the principle of recursive definition as there are on the principle of induction. For example, in analogy to the principle of complete induction, we can specify a value of :math:`f(n)` in terms of the values that :math:`f` takes at all inputs smaller than :math:`n`. When :math:`n \geq 2`, for example, the following definition specifies the value of a function :math:`\mathrm{fib}(n)` in terms of its two predecessors:

.. math::

     \mathrm{fib}(0) & = 0 \\
     \mathrm{fib}(1) & = 1 \\
     \mathrm{fib}(n+2) & = \mathrm{fib}(n + 1) + \mathrm{fib}(n)

Calculating the values of :math:`\mathrm{fib}` on :math:`0, 1, 2, \ldots` we obtain

.. math::

   0, 1, 1, 2, 3, 5, 8, 13, 21, \ldots

Here, after the second number, each successive number is the sum of the two values preceding it. This is known as the *Fibonacci sequence*, and the corresponding numbers are known as the *Fibonacci numbers*. An ordinary mathematical presentation would write :math:`F_n` instead of :math:`\mathrm{fib}(n)` and specify the sequence with the following equations:

.. math::

   F_0 = 0, \quad F_1 = 1, \quad F_{n+2} = F_{n+1} + F_n

But you can now recognize such a specification as an implicit appeal to the principle of definition by recursion. We ask you to prove some facts about the Fibonacci sequence in the exercises below.

.. _defining_arithmetic_operations:

Defining Arithmetic Operations
------------------------------

In fact, we can even use the principle of recursive definition to define the most basic operations on the natural numbers and show that they have the properties we expect them to have. From a foundational standpoint, we can characterize the natural numbers as a set, :math:`\mathbb{N}`, with a distinguished element :math:`0` and a function, :math:`\mathrm{succ}(m)`, which, for every natural number :math:`m`, returns its *successor*. These satisfy the following:

-  :math:`0 \neq \mathrm{succ}(m)` for any :math:`m` in :math:`\mathbb{N}`.
-  For every :math:`m` and :math:`n` in :math:`\mathbb{N}`, if :math:`m \neq n`, then :math:`\mathrm{succ}(m) \neq \mathrm{succ}(n)`. In other words, :math:`\mathrm{succ}` is *injective*.
-  If :math:`A` is any subset of :math:`\mathbb{N}` with the property that :math:`0` is in :math:`A` and whenever :math:`n` is in :math:`A` then :math:`\mathrm{succ}(n)` is in :math:`A`, then :math:`A = \mathbb{N}`.

The last clause can be reformulated as the principle of induction:

    Suppose :math:`P(n)` is any property of natural numbers, such that :math:`P` holds of :math:`0`, and for every :math:`n`, :math:`P(n)` implies :math:`P(\mathrm{succ}(n))`. Then every :math:`P` holds of every natural number.

Remember that this principle can be used to justify the principle of definition by recursion:

    Let :math:`A` be any set, :math:`a` be any element of :math:`A`, and let :math:`g(n,m)` be any function from :math:`\mathbb{N} \times A` to :math:`A`. Then there is a unique function :math:`f: \mathbb{N} \to A` satisfying the following two clauses:

    -  :math:`f(0) = a`
    -  :math:`f(\mathrm{succ}(n)) = g(n,f(n))` for every :math:`n` in :math:`N`

We can use the principle of recursive definition to define addition with the following two clauses:

.. math::

   m + 0 & = m \\
   m + \mathrm{succ}(n) & = \mathrm{succ}(m + n)

Note that we are fixing :math:`m`, and viewing this as a function of :math:`n`. If we write :math:`1 = \mathrm{succ}(0)`, :math:`2 = \mathrm{succ}(1)`, and so on, it is easy to prove :math:`n + 1 = \mathrm{succ}(n)` from the definition of addition.

We can proceed to define multiplication using the following two clauses:

.. math::

   m \cdot 0 & = 0 \\
   m \cdot \mathrm{succ}(n) & = m \cdot n + m

We can also define a predecessor function by

.. math::

   \mathrm{pred}(0) & = 0 \\
   \mathrm{pred}(\mathrm{succ}(n)) & = n

We can define *truncated subtraction* by

.. math::

   m \dot - 0 & = m \\
   m \dot - (\mathrm{succ}(n)) & = \mathrm{pred}(m \dot - n)

With these definitions and the induction principle, one can prove all the following identities:

-  :math:`n \neq 0` implies :math:`\mathrm{succ}(\mathrm{pred}(n)) = n`
-  :math:`0 + n = n`
-  :math:`\mathrm{succ}(m) + n = \mathrm{succ}(m + n)`
-  :math:`(m + n) + k = m + (n + k)`
-  :math:`m + n = n + m`
-  :math:`m(n + k) = mn + mk`
-  :math:`0 \cdot n = 0`
-  :math:`1 \cdot n = n`
-  :math:`(mn)k = m(nk)`
-  :math:`mn = nm`

We will do the first five here, and leave the remaining ones as exercises.

----

**Proposition.** For every natural number :math:`n`, if :math:`n \neq 0` then :math:`\mathrm{succ}(\mathrm{pred}(n)) = n`.

**Proof.** By induction on :math:`n`. We have ruled out the case where :math:`n` is :math:`0`, so we only need to show that the claim holds for :math:`\mathrm{succ}(n)`. But in that case, we have :math:`\mathrm{succ}(\mathrm{pred}(\mathrm{succ}(n)) = \mathrm{succ}(n)` by the second defining clause of the predecessor function.

**Proposition.** For every :math:`n`, :math:`0 + n = n`.

**Proof.** By induction on :math:`n`. We have :math:`0 + 0 = 0` by the first defining clause for addition. And assuming :math:`0 + n = n`, we have :math:`0 + \mathrm{succ}(n) = \mathrm{succ}(0 + n) = n`, using the second defining clause for addition.

**Proposition.** For every :math:`m` and :math:`n`, :math:`\mathrm{succ}(m) + n = \mathrm{succ}(m + n)`.

**Proof.** Fix :math:`m` and use induction on :math:`n`. Then :math:`n = 0`, we have :math:`\mathrm{succ}(m) + 0 = \mathrm{succ}(m) = \mathrm{succ}(m + 0)`, using the first defining clause for addition. Assuming the claim holds for :math:`n`, we have

.. math::

   \mathrm{succ}(m) + \mathrm{succ}(n) & = \mathrm{succ}(\mathrm{succ}(m) + n) \\
   & = \mathrm{succ} (\mathrm{succ} (m + n)) \\
   & = \mathrm{succ} (m + \mathrm{succ}(n))

using the inductive hypothesis and the second defining clause for addition.

**Proposition.** For every :math:`m`, :math:`n`, and :math:`k`, :math:`(m + n) + k = m + (n + k)`.

**Proof.** By induction on :math:`k`. The case where :math:`k = 0` is easy, and in the induction step we have

.. math::

   (m + n) + \mathrm{succ}(k) & = \mathrm{succ} ((m + n) + k) \\
   & = \mathrm{succ} (m + (n + k)) \\
   & = m + \mathrm{succ} (n + k) \\
   & = m + (n + \mathrm{succ} (k)))

using the inductive hypothesis and the definition of addition.

**Proposition.** For every pair of natural numbers :math:`m` and :math:`n`, :math:`m + n = n + m`.

**Proof.** By induction on :math:`n`. The base case is easy using the second proposition above. In the inductive step, we have

.. math::

   m + \mathrm{succ}(n) & = \mathrm{succ}(m + n) \\
   & = \mathrm{succ} (n + m) \\
   & = \mathrm{succ}(n) + m

using the third proposition above.

----

.. _arithmetic_on_the_natural_numbers:

Arithmetic on the Natural Numbers
---------------------------------

Continuing as in the last section, we can establish all the basic properties of the natural numbers that play a role in day-to-day mathematics. We summarize the main ones here:

.. math::

   m + n &= n + m \quad \text{(commutativity of addition)}\\
   m + (n + k) &= (m + n) + k \quad \text{(associativity of addition)}\\
   n + 0 &= n \quad \text{($0$ is a neutral element for addition)}\\
   n \cdot m &= m \cdot n \quad \text{(commutativity of multiplication)}\\
   m \cdot (n \cdot k) &= (m \cdot n) \cdot k \quad \text{(associativity of multiplication)}\\
   n \cdot 1 &= n \quad \text{($1$ is an neutral element for multiplication)}\\
   n \cdot (m + k) &= n \cdot m + n \cdot k \quad \text{(distributivity)}\\
   n \cdot 0 &= 0 \quad \text{($0$ is an absorbing element for multiplication)}

In an ordinary mathematical argument or calculation, they can be used without explicit justification. We also have the following properties:

-  :math:`n + 1 \neq 0`
-  if :math:`n + k = m + k` then :math:`n = m`
-  if :math:`n \cdot k = m \cdot k` and :math:`k \neq 0` then :math:`n = m`

We can define :math:`m \le n`, ":math:`m` is less than or equal to :math:`n`," to mean that there exists a :math:`k` such that :math:`m + k = n`. If we do that, it is not hard to show that the less-than-or-equal-to relation satisfies all the following properties, for every :math:`n`, :math:`m`, and :math:`k`:

-  :math:`n \le n` (*reflexivity*)
-  if :math:`n \le m` and :math:`m \le k` then :math:`n \le k` (*transitivity*)
-  if :math:`n \le m` and :math:`m \le n` then :math:`n = m` (*antisymmetry*)
-  for all :math:`n` and :math:`m`, either :math:`n \le m` or :math:`m \le n` is true (*totality*)
-  if :math:`n \le m` then :math:`n + k \le m + k`
-  if :math:`n + k \le m + k` then :math:`n \le m`
-  if :math:`n \le m` then :math:`nk \le mk`
-  if :math:`m \ge n` then :math:`m = n` or :math:`m \ge n + 1`
-  :math:`0 \le n`

Remember from :numref:`Chapter %s <relations>` that the first four items assert that :math:`\le` is a linear order. Note that when we write :math:`m \ge n`, we mean :math:`n \le m`.

As usual, then, we can define :math:`m < n` to mean that :math:`m \le n` and :math:`m \ne n`. In that case, we have that :math:`m \le n` holds if and only if :math:`m < n` or :math:`m = n`.

----

**Proposition.** For every :math:`m`, :math:`m + 1 \not\le 0`.

**Proof.** Otherwise, we would have :math:`(m + 1) + k = (m + k) + 1 = 0` for some :math:`k`.

----

In particular, taking :math:`m = 0`, we have :math:`1 \not\le 0`.

----

**Proposition.** We have :math:`m < n` if and only if :math:`m + 1 \le n`.

**Proof.** Suppose :math:`m < n`. Then :math:`m \le n` and :math:`m \ne n`. So there is a :math:`k` such that :math:`m + k = n`, and since :math:`m \ne n`, we have :math:`k \ne 0`. Then :math:`k = u + 1` for some :math:`u`, which means we have :math:`m + (u + 1) = m + 1 + u = n`, so :math:`m \le n`, as required.

In the other direction, suppose :math:`m + 1 \le n`. Then :math:`m \le n`. We also have :math:`m \ne n`, since if :math:`m = n`, we would have :math:`m + 1 \le m + 0` and hence :math:`1 \le 0`, a contradiction.

----

In a similar way, we can show that :math:`m < n` if and only if :math:`m \le n` and :math:`m \ne n`. In fact, we can demonstrate all of the following from these properties and the properties of :math:`\le`:

-  :math:`n < n` is never true (*irreflexivity*)
-  if :math:`n < m` and :math:`m < k` then :math:`n < k` (*transitivity*)
-  for all :math:`n` and :math:`m`, either :math:`n < m`, :math:`n = m` or :math:`m < n` is true (*trichotomy*)
-  if :math:`n < m` then :math:`n + k < m + k`
-  if :math:`k > 0` and :math:`n < m` then :math:`nk < mk`
-  if :math:`m > n` then :math:`m = n + 1` or :math:`m > n + 1`
-  for all :math:`n`, :math:`n = 0` or :math:`n > 0`

The first three items mean that :math:`<` is a strict linear order, and the properties above means that :math:`\le` is the associated linear order, in the sense described in :numref:`order_relations`.

----

**Proof**. We will prove some of these properties using the previous characterization of the less-than relation.

The first property is straightforward: we know :math:`n \le n + 1`, and if we had :math:`n + 1 \le n`, we should have :math:`n = n + 1`, a contradiction.

For the second property, assume :math:`n < m` and :math:`m < k`. Then :math:`n + 1 \le m \le m + 1 \le k`, which implies :math:`n < k`.

For the third, we know that either :math:`n \le m` or :math:`m \le n`. If :math:`m = n`, we are done, and otherwise we have either :math:`n < m` or :math:`m < n`.

For the fourth, if :math:`n + 1 \le m`, we have :math:`n + 1 + k = (n + k) + 1 \le m + k`, as required.

For the fifth, suppose :math:`k > 0`, which is to say, :math:`k \ge 1`. If :math:`n < m`, then :math:`n + 1 \le m`, and so :math:`nk + 1 \le n k + k \le mk`. But this implies :math:`n k < m k`, as required.

The rest of the remaining proofs are left as an exercise to the reader.

----

Here are some additional properties of :math:`<` and :math:`\le`:

-  :math:`n < m` and :math:`m < n` cannot both hold (*asymmetry*)
-  :math:`n + 1 > n`
-  if :math:`n < m` and :math:`m \le k` then :math:`n < k`
-  if :math:`n \le m` and :math:`m < k` then :math:`n < k`
-  if :math:`m > n` then :math:`m \ge n + 1`
-  if :math:`m \ge n` then :math:`m + 1 > n`
-  if :math:`n + k < m + k` then :math:`n < m`
-  if :math:`nk < mk` then :math:`k > 0` and :math:`n < m`

These can be proved from the ones above. Moreover, the collection of principles we have just seen can be used to justify basic facts about the natural numbers, which are again typically taken for granted in informal mathematical arguments.

----

**Proposition.** If :math:`m` and :math:`n` are natural numbers such that :math:`m + n = 0`, then :math:`m = n = 0`.

**Proof.** If :math:`m + n = 0`, then :math:`m \le 0`, so :math:`m = 0` and :math:`n = 0 + n = m + n = 0`.

**Proposition.** If :math:`n` is a natural number such that :math:`n < 3`, then :math:`n = 0`, :math:`n = 1` or :math:`n = 2`.

**Proof.** In this proof we repeatedly use the property that if :math:`m > n` then :math:`m = n + 1` or :math:`m > n + 1`. Since :math:`2 + 1 = 3 > n`, we conclude that either :math:`2 + 1 = n + 1` or :math:`2 + 1 > n + 1`. In the first case we conclude :math:`n = 2`, and we are done. In the second case we conclude :math:`2 > n`, which implies that either :math:`2 = n + 1`, or :math:`2 > n + 1`. In the first case, we conclude :math:`n = 1`, and we are done. In the second case, we conclude :math:`1 > n`, and appeal one last time to the general principle presented above to conclude that either :math:`1 = n + 1` or :math:`1 > n + 1`. In the first case, we conclude :math:`n = 0`, and we are once again done. In the second case, we conclude that :math:`0 > n`. This leads to a contradiction, since now :math:`0 > n \ge 0`, hence :math:`0 > 0`, which contradicts the irreflexivity of :math:`>`.

----

.. _the_integers:

The Integers
------------

The natural numbers are designed for counting discrete quantities, but they suffer an annoying drawback: it is possible to subtract :math:`n` from :math:`m` if :math:`n` is less than or equal to :math:`m`, but not if :math:`m` is greater than :math:`n`. The set of *integers*, :math:`\mathbb{Z}`, extends the natural numbers with negative values, to make it possible to carry out subtraction in full:

.. math::

   \mathbb{Z} = \{ \ldots, -3, -2, -1, 0, 1, 2, 3, \ldots \}.

We will see in a later chapter that the integers can be extended to the *rational numbers*, the *real numbers*, and the *complex numbers*, each of which serves useful purposes. For dealing with discrete quantities, however, the integers will get us pretty far.

You can think of the integers as consisting of two copies of the natural numbers, a positive one and a negative one, sharing a common zero. Conversely, once we have the integers, you can think of the natural numbers as consisting of the nonnegative integers, that is, the integers that are greater than or equal to :math:`0`. Most mathematicians blur the distinction between the two, though we will see that in Lean, for example, the natural numbers and the integers represent two different data types.

Most of the properties of the natural numbers that were enumerated in the last section hold of the integers as well, but not all. For example, it is no longer the case that :math:`n + 1 \neq 0` for every :math:`n`, since the claim is false for :math:`n = -1`. For another example, it is not the case that every integer is either equal to :math:`0` or greater than :math:`0`, since this fails to hold of the negative integers.

The key property that the integers enjoy, which sets them apart from the natural numbers, is that for every integer :math:`n` there is a value :math:`-n` with the property that :math:`n + (-n) = 0`. The value :math:`-n` is called the *negation* of :math:`n`. We define subtraction :math:`n - m` to be :math:`n + (-m)`. For any integer :math:`n`, we also define the *absolute value* of :math:`n`, written :math:`|n|`, to be :math:`n` if :math:`n \geq 0`, and :math:`-n` otherwise.

We can no longer use proof by induction on the integers, because induction does not cover the negative numbers. But we can use induction to show that a property holds of every nonnegative integer, for example. Moreover, we know that every negative integer is the negation of a positive one. As a result, proofs involving the integers often break down into two cases, where one case covers the nonnegative integers, and the other case covers the negative ones.

Exercises
---------

#. Write the principle of complete induction using the notation of symbolic logic. Also write the least element principle this way, and use logical manipulations to show that the two are equivalent.

#. Show that for every :math:`n`, :math:`0^2 + 1^2 + 2^2 + \ldots n^2= \frac{1}{6}n(1+n)(1+2n)`.

#. Show that for every :math:`n`, :math:`0^3 + 1^3 + \ldots + n^3 = \frac{1}{4} n^2 (n+1)^2`.

#. Show that for every :math:`n`, :math:`\sum_{i \le n} \frac{i}{(i + 1)!} = \frac{n! - 1}{n}`.

#. Given the definition of the Fibonacci numbers in :numref:`recursive_definitions`, prove Cassini's identity: for every :math:`n`, :math:`F^2_{n+1} - F_{n+2} F_n = (-1)^n`. Hint: in the induction step, write :math:`F_{n+2}^2` as :math:`F_{n+2}(F_{n+1} + F_n)`.

#. Prove :math:`\sum_{i < n} F_{2i+1} = F_{2n}`.

#. Prove the following two identities:

   -  :math:`F_{2n+1} = F^2_{n+1} + F^2_n`
   -  :math:`F_{2n+2} = F^2_{n+2} - F^2_n`

   Hint: use induction on :math:`n`, and prove them both at once. In the induction step, expand :math:`F_{2n+3} = F_{2n+2} + F_{2n+1}`, and similarly for :math:`F_{2n+4}`. Proving the second equation is especially tricky. Use the inductive hypothesis and the first identity to simplify the left-hand side, and repeatedly unfold the Fibonacci number with the highest index and simplify the equation you need to prove. (When you have worked out a solution, write a clear equational proof, calculating in the \`\`forward'' direction.)

#. Prove that every natural number can be written as a sum of *distinct* powers of 2. For this problem, :math:`1 = 2^0` is counted as power of 2.

#. Let :math:`V` be a non-empty set of integers such that the following two properties hold:

   -  If :math:`x, y \in V`, then :math:`x - y \in V`.
   -  If :math:`x \in V`, then every multiple of :math:`x` is an element of :math:`V`.

   Prove that there is some :math:`d \in V`, such that :math:`V` is equal to the set of multiples of :math:`d`. Hint: use the least element principle.

#. Give an informal but detailed proof that for every natural number :math:`n`, :math:`1 \cdot n = n`, using a proof by induction, the definition of multiplication, and the theorems proved in :numref:`defining_arithmetic_operations`.

#. Show that multiplication distributes over addition. In other words, prove that for natural numbers :math:`m`, :math:`n`, and :math:`k`, :math:`m (n + k) = m n + m k`. You should use the definitions of addition and multiplication and facts proved in :numref:`defining_arithmetic_operations` (but nothing more).

#. Prove the multiplication is associative, in the same way. You can use any of the facts proved in :numref:`defining_arithmetic_operations` and the previous exercise.

#. Prove that multiplication is commutative.

#. Prove :math:`(m^n)^k = m^{nk}`.

#. Following the example in :numref:`arithmetic_on_the_natural_numbers`, prove that if :math:`n` is a natural number and :math:`n < 5`, then :math:`n` is one of the values :math:`0, 1, 2, 3`, or :math:`4`.

#. Prove that if :math:`n` and :math:`m` are natural numbers and :math:`n m = 1`, then :math:`n = m = 1`, using only properties listed in :numref:`arithmetic_on_the_natural_numbers`.

   This is tricky. First show that :math:`n` and :math:`m` are greater than :math:`0`, and hence greater than or equal to :math:`1`. Then show that if either one of them is greater than :math:`1`, then :math:`n m > 1`.

#. Prove any of the other claims in :numref:`arithmetic_on_the_natural_numbers` that were stated without proof.

#. Prove the following properties of negation and subtraction on the integers, using only the properties of negation and subtraction given in :numref:`the_integers`.

   -  If :math:`n + m = 0` then :math:`m = -n`.
   -  :math:`-0 = 0`.
   -  If :math:`-n = -m` then :math:`n = m`.
   -  :math:`m + (n - m) = n`.
   -  :math:`-(n + m) = -n - m`.
   -  If :math:`m < n` then :math:`n - m > 0`.
   -  If :math:`m < n` then :math:`-m > -n`.
   -  :math:`n \cdot (-m) = -nm`.
   -  :math:`n(m - k) = nm - nk`.
   -  If :math:`n < m` then :math:`n - k < m - k`.

#. Suppose you have an infinite chessboard with a natural number written in each square. The value in each square is the average of the values of the four neighboring squares. Prove that all the values on the chessboard are equal.

#. Prove that every natural number can be written as a sum of *distinct non-consecutive* Fibonacci numbers. For example, :math:`22 = 1 + 3 + 5 + 13` is not allowed, since 3 and 5 are consecutive Fibonacci numbers, but :math:`22 = 1 + 21` is allowed.
